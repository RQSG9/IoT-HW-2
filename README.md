# 지능시스템 Homwork 2
지능시스템 과제 2: chapter 4 ~ chapter 5의 모든 예제 github에 push하기

## Chapter 4

### EX 4-1
 - setInterval 함수의 사용법
 - setInterval 함수를 호출, 익명 함수를 300밀리초(0.3초) 간격으로 반복 실행
 - setInterval의 고유 ID는 timer 변수에 저장
 - count가 5가 되면, clearInterval(timer) 함수를 호출, 주기적인 함수 실행을 중단

### EX 4-2
 - 예제 4-1과 같은 작업을 수행하지만, 콜백 함수를 별도로 선언
 - 콜백 함수와 이를 호출하는 함수 간의 제어권 관계를 이해
 - 결과적으로 cbFunc는 0.3초 간격으로 5회 호출

### EX 4-3
 - 배열의 각 요소에 대해 주어진 콜백 함수를 실행하고, 그 함수의 반환 값들로 이루어진 새로운 배열을 만드는 map 메서드
 - map()에 전달되는 콜백 함수는 배열의 각 currentValue와 index를 인자로 받아 실행되어 새 값을 반환
 - 연산을 통해 각 요소에 5가 더해진 새로운 배열이 newArr 변수에 할당되고 콘솔에 출력

### EX 4-4
 - map 메서드가 콜백 함수를 호출할 때 전달하는 인자들의 순서는 정해져 있음
 - 콜백 함수를 정의할 때 사용하는 매개변수 이름은 이 순서에 영향을 주지 않음
 - 이로 인해 map이 첫 번째로 전달하는 '요소 값'이 index 변수에, 두 번째로 전달하는 '인덱스'가 currentValue 변수에 담김

### EX 4-5
 - Array.prototype.map 메서드 직접 구현
 - 구현된 map 함수는 사용자 정의 콜백 함수를 호출할 때, 표준 map 메서드와 동일하게 현재 요소 값(this[i]), 현재 인덱스(i), 그리고 원본 배열(this)을 순서대로 전달

### EX 4-6
 - 다양한 상황에서 콜백 함수 내부의 this 결정
 - setTimeout에 전달된 콜백 함수 내에서 this는 전역 객체
 - forEach 메서드에 두 번째 인자로 this 컨텍스트를 지정하지 않았으므로, 콜백 함수 내의 this는 전역 객체
 - addEventListener를 통해 등록된 콜백 함수 내에서 this는 이벤트를 발생시킨 HTML 요소

### EX 4-7
 - 객체의 메서드를 콜백 함수로 사용할 때 발생하는 this 변화
 - obj.logValues라는 동일한 함수를 객체의 메서드로 직접 호출하는 경우와 forEach의 콜백 함수로 전달하는 경우의 차이
 - 메서드로 호출하면, this는 메서드를 소유한 객체 obj
 - 메서드를 콜백으로 전달하면, 해당 함수는 메서드가 아닌 함수 취급, forEach 호출 시 this를 별도로 지정하지 않았으므로, 콜백 내부의 this는 전역 객체

### EX 4-8
 - 콜백 함수 내부의 this에 다른 값 바인딩
 - var self = this; 구문을 사용, obj1을 self 변수에 저장
 - this 바인딩 문제를 해결하는 전통적인 방법이지만, 번거로움

### EX 4-9
 - this를 사용하는 대신, 콜백 함수에서 직접 obj1.name과 같이 객체 변수를 참조하여 문제를 회피하는 간단한 방법
 - 다양한 상황에 재활용 불가능

### EX 4-10
 - var self = this;를 통해 this를 바인딩했을 경우의 유연성과 재사용성 확인
 - obj2.func()를 호출하면, obj1.func 내부의 this는 obj2
 - obj1.func.call(obj3)는 .call 메서드를 사용하여 obj1.func를 실행할 때 this 값을 강제로 obj3로 지정

### EX 4-11
 - bind 메서드를 사용하여 콜백 함수의 this 값을 명시적으로 지정하는 방법

### EX 4-12
 - 비동기 함수(setTimeout)를 연속적으로 중첩 호출함으로써 코드가 들여쓰기 때문에 오른쪽으로 계속 깊어지는 형태가 되어 가독성이 떨어지는 '콜백 지옥' 패턴
 - 중첩된 함수들은 상위 스코프의 coffeeList 변수에 접근하여 값을 누적적으로 변경, 0.5초 간격으로 작업이 순차적으로 실행
 - 코드가 깊게 중첩됨에 따라 전체적인 흐름 파악 어려움

### EX 4-13
 - 예제 4-12의 '콜백 지옥' 문제를 개선하기 위한 방법
 - 기명 함수로 비동기 작업의 각 단계를 분리, 중첩된 구조를 풀어서 가독성 향상
 - 여전히 콜백 패턴에 의존하는 한계, 더 복잡한 비동기 로직에서는 어려움이 있을 수 있음

### EX 4-14
 - Promise를 사용하여, 콜백 지옥 문제를 해결하고 비동기 작업을 더욱 구조적이고 가독성 높게 처리하는 방법
 - 이전 Promise가 성공적으로 완료(resolve)되면 .then()은 이전 결과 값을 인자로 받아 다음 작업을 수행

### EX 4-15
 - 반복적인 내용을 함수화하여 예제 4-14 내용을 간결하게 표현

### EX 4-16
 - Generator와 yield 키워드를 사용하여 비동기 작업을 동기 코드처럼 보이게 작성하는 방법
 - Generator 내부에서 yield 키워드는 함수의 실행을 일시 중지, yield 뒤에는 비동기 작업을 시작하는 addCoffee 함수가 호출
 - addCoffee 함수 작업이 완료되면 coffeeMaker.next()를 호출하여 제너레이터의 실행을 재개시키고, 결과값을 yield 표현식의 반환값으로 전달

### EX 4-17
 - async/await 문법을 사용하여 비동기 작업을 동기 코드처럼 작성하는 방법
 - 코드가 한 줄씩 순서대로 실행되는 동기 코드와 매우 유사

## Chapter 5

### EX 5-1
 - 외부 함수의 변수를 참조하는 내부 함수 예제
 - inner 함수의 스코프에서 변수 a를 찾을 수 없기 때문에, 스코프 체인을 따라 외부함수 outer의 a 변수 참조

### EX 5-2
 - 외부 함수의 변수를 참조하는 내부 함수 예제
 - 내부 함수 inner는 ++a의 결과를 반환하고, 외부 함수 outer는 inner 함수를 호출한 결과를 반환

### EX 5-3
 - 외부 함수가 종료된 후에도 내부 함수를 통해 외부 함수의 변수에 접근하는 예제
 - 이 예제의 가장 큰 특징은 outer가 내부 함수 inner 자체를 반환한다는 점
 - outer 함수는 실행이 종료되지만, 반환된 inner 함수는 자신이 선언될 당시의 Lexical Environment에 대한 참조outerEnvironmentReference를 계속 유지
 - 클로저: 어떤 함수 A에서 선언한 변수 a를 참조하는 내부 변수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상

### EX 5-4
 - return 없이도 클로저가 발생하는 경우를 보여주는 예제
 - setInterval나 addEventListener와 같이 비동기적으로 실행되는 콜백 함수에서 클로저가 어떻게 상태를 유지하고 관리하는 데 사용되는지 보여줌

### EX 5-5
 - 클로저를 사용할 때 발생할 수 있는 메모리 누수 문제 및 관리 방법 예제
 - 클로저를 사용하는 비동기 작업이나 이벤트 핸들러의 작업이 완료되거나 더 이상 필요 없을 때, null을 할당하여 함수 참조를 끊음

### EX 5-6
 - 반복문(forEach) 안에서 이벤트 리스너를 추가할 때 클로저가 어떻게 활용되어 각 요소가 자신만의 데이터를 올바르게 참조하게 하는지 보여주는 예제
 - fruits 배열의 각 항목 apple, banana, peach에 대해 &lt;li&gt; 요소를 만들고, 각 요소에 텍스트를 설정한 후 클릭 이벤트 리스너를 개별적으로 추가
 - addEventListener에 전달된 콜백 함수는 forEach 콜백 함수의 스코프를 참조하므로 클로저 존재

### EX 5-7
 - 반복문 내에서 이름 있는 함수를 이벤트 리스너로 사용할 때 발생할 수 있는 문제점
 - addEventListener는 이벤트 발생 시 콜백 함수를 호출하지만, fruit 값을 인자로 넘겨주지 않음
 - &lt;li&gt;를 클릭하면 alertFruit 함수가 실행되지만, fruit 매개변수에는 Event 객체가 전달, 의도하지 않은 내용이 표시됨

### EX 5-8
 - bind 메서드를 활용하여, 반복문 내에서 이벤트 리스너를 추가할 때 각 요소에 맞는 특정 데이터를 인자로 전달하는 방법

### EX 5-9
 - 고차 함수를 이용하여, 반복문 내에서 이벤트 리스너가 고유한 데이터를 참조하도록 만드는 방법

### EX 5-10
 - 자동차(car)를 표현하는 객체
 - fuel(연료), power(연비), moved(이동 거리)라는 상태 프로퍼티와 run(주행)이라는 메서드를 가짐
 - 사용자가 임의로 연료, 연비, 이동 거리를 바꿀 수 있음

### EX 5-11
 - 클로저를 활용하여 정보를 은닉하는 방법
 - createCar 함수 내부에 선언된 fuel, power변수는 외부에서 직접 접근할 수 없음
 - run 메서드를 실행하고 현재의 moved를 확인하는 것만 가능

### EX 5-12
 - 예제 5-11에 Object.freeze()를 추가, 생성된 객체의 메서드 및 getter 자체를 변경 불가능하게 만들어 안정성을 강화
 - 클로저를 통해 정보 은닉에 더하여, 외부로 노출되는 메서드와 getter 자체를 변경하지 못하게 함

### EX 5-13
 - 원본 함수의 일부 인자를 미리 고정시켜 놓은 새로운 함수인 부분 적용 함수
 - add.bind(null, 1, 2, 3, 4, 5)는 add 함수를 기반으로 하되, this는 null로 설정하고, 1, 2, 3, 4, 5를 항상 첫 번째부터 다섯 번째 인자로 사용하는 addPartial 함수를 생성
 - addPartial(6, 7, 8, 9, 10)를 호출하면, add 함수는 고정된 인자 1~5와 새로운 인자 6~10을 모두 받아서 합계를 계산, 콘솔에는 55가 출력